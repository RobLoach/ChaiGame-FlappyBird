global bird
global assets
global pipes = []
global pipetimer = 0.0f
global pipetimerCountdown = 1.4f
global score = 0
global openingSizeStart = 75.0f
global openingSize = 75.0f
global openingSizeRange = 10.0f
global flapTimer = 0.0f
global flapTimerMax = 0.10f
global landTop = 0
global landX = 0.0f
global skyX = 0.0f
global highscore = 0

def conf(t) {
	t.window.title = "Floppy Bird";
	t.window.width = 480;
	t.window.height = 480;
}

def load() {
	graphics.setBackgroundColor(78, 192, 202)
	filesystem.load("Assets.chai")
	filesystem.load("Bird.chai")
	filesystem.load("Pipe.chai")

	assets = Assets()
	assets.get("music").setLooping(true)
	assets.get("music").play()
	bird = Bird(assets)
	landTop = graphics.getHeight() - assets.get("land").getHeight()

	reset()
}

def reset() {
	pipes.clear()
	addPipe()
	bird.reset()
	score = 0
	openingSize = 75.0f
	openingSizeRange = 10.0f
	pipetimer = 0.0f
	flapTimer = 0.0f
	openingSize = 70.0f
	landX = 0.0f
}

def addPipe() {
	// Find out where the pipes should be positioned.
	var pipeImage := assets.get("pipe-up")
	var opening = math.random(0 + pipeImage.getHeight() + openingSize, landTop - pipeImage.getHeight() - openingSize)
	var openSize = openingSize + math.random(-openingSizeRange, openingSizeRange)

	// Add the pipes to the game.
	pipes.push_back(Pipe(assets, opening, true, openSize))
	pipes.push_back(Pipe(assets, opening, false, openSize))
}

def draw() {
	if (config.options["highquality"]) {
		var sky := assets.get("sky")
		for (var i = 0; (i - 1) * sky.getWidth() <= graphics.getWidth(); ++i) {
			graphics.draw(sky, i * sky.getWidth() - skyX, landTop - sky.getHeight())
		}
	}

	var land := assets.get("land")
	for (var i = 0; (i - 1) * land.getWidth() <= graphics.getWidth(); ++i) {
		graphics.draw(land, i * land.getWidth() - landX, graphics.getHeight() - land.getHeight())
	}

	// Draw the Bird
	bird.draw()

	// Draw all the pipes
	for (pipe : pipes) {
		pipe.draw()
	}

	// Print the score.
	graphics.setFont(assets.get("font-big"))
	graphics.print(to_string(score), graphics.getWidth() / 2 - 30, 30)

	// FPS
	graphics.setFont(assets.get("font-pixel"))
	graphics.print("FPS " + to_string(timer.getFPS()), 10, graphics.getHeight() - 20)


	// Highscore
	graphics.print("BEST " + to_string(highscore), graphics.getWidth() - 150, graphics.getHeight() - 20)
}

def update(delta) {
	// Update the bird position, resetting if needed.
	if (bird.update(delta) == false) {
		reset()
		return
	}

	// Update all pipes.
	var removePipe = -1
	for (var i = 0; i < pipes.size(); ++i) {
		// Check collisions with any pipes.
		if (pipes[i].collide(bird)) {
			assets.get("hit").play()
			reset()
			return
		}

		// Update will return false if we are to remove it.
		if (pipes[i].update(delta, bird.speed) == false) {
			removePipe = i
		}

		// Count the score.
		if (bird.x > pipes[i].x + pipes[i].width / 2 && pipes[i].top && pipes[i].scored == false) {
			addScore()
			pipes[i].scored = true
		}
	}

	// See if we are removing an old pipe.
	if (removePipe >= 0) {
		pipes.erase_at(removePipe)
	}

	// Add a new pipe if needed.
	pipetimer += delta
	if (pipetimer > pipetimerCountdown) {
		pipetimer = 0.0f
		addPipe()
	}

	landX += bird.speed * delta
	if (landX >= assets.get("land").getWidth()) {
		landX = 0.0f
	}

	skyX += bird.speed / 2 * delta
	if (skyX >= assets.get("sky").getWidth()) {
		skyX = 0.0f
	}

	flapTimer += delta
}

def joystickpressed(joy, button) {
	if (flapTimer > flapTimerMax) {
		bird.flap(false)
		flapTimer = 0.0f
	}
}

def mousepressed(x, y, button) {
	joystickpressed(0, 0)
}

def addScore() {
	score += 1
	assets.get("point").play()

	// Update the highscore.
	if (score > highscore) {
		highscore = score
	}
}

/**
 * Callback to save the current state as a JSON object.
 */
def savestate() {
	var info = ["highscore": highscore]
	return to_json(info)
}

/**
 * Callback to load the state from a JSON object.
 */
def loadstate(data) {
	var info = from_json(data)
	highscore = info["highscore"]
	return true
}
